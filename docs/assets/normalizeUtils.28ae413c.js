import{m as $,k as q,c as E,a as U,v,L as C,b as F,e as _,f as B,h as H,t as K,R as Q,r as V,i as W,l as k,p as Y,s as Z}from"./index.96cac272.js";const A={102100:{maxX:20037508342788905e-9,minX:-20037508342788905e-9,plus180Line:new $({paths:[[[20037508342788905e-9,-20037508342788905e-9],[20037508342788905e-9,20037508342788905e-9]]],spatialReference:q.WebMercator}),minus180Line:new $({paths:[[[-20037508342788905e-9,-20037508342788905e-9],[-20037508342788905e-9,20037508342788905e-9]]],spatialReference:q.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new $({paths:[[[180,-180],[180,180]]],spatialReference:q.WGS84}),minus180Line:new $({paths:[[[-180,-180],[-180,180]]],spatialReference:q.WGS84})}};function L(e,n){return Math.ceil((e-n)/(2*n))}function D(e,n){const i=O(e);for(const s of i)for(const t of s)t[0]+=n;return e}function O(e){return E(e)?e.rings:e.paths}async function ee(e,n,i,s){const t=typeof e=="string"?U(e):e,f=n[0].spatialReference,a={...s,query:{...t.query,f:"json",sr:JSON.stringify(f),target:JSON.stringify({geometryType:v(n[0]),geometries:n}),cutter:JSON.stringify(i)}},r=await C(t.path+"/cut",a),{cutIndexes:l,geometries:m=[]}=r.data;return{cutIndexes:l,geometries:m.map(h=>{const x=F(h);return x.spatialReference=f,x})}}async function te(e,n,i){const s=typeof e=="string"?U(e):e,t=n[0].spatialReference,f=v(n[0]),a={...i,query:{...s.query,f:"json",sr:t.wkid?t.wkid:JSON.stringify(t),geometries:JSON.stringify(ne(n))}};return se((await C(s.path+"/simplify",a)).data,f,t)}function ne(e){return{geometryType:v(e[0]),geometries:e.map(n=>n.toJSON())}}function se(e,n,i){const s=_(n);return e.map(t=>{const f=s.fromJSON(t);return f.spatialReference=i,f})}const G=B.getLogger("esri.geometry.support.normalizeUtils");function oe(e){return e.type==="polygon"}function re(e){return e[0].type==="polygon"}function ie(e){return e[0].type==="polyline"}function ce(e,n){if(!(e instanceof $||e instanceof k)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw G.error(t),new Z(t)}const i=O(e),s=[];for(const t of i){const f=[];s.push(f),f.push([t[0][0],t[0][1]]);for(let a=0;a<t.length-1;a++){const r=t[a][0],l=t[a][1],m=t[a+1][0],h=t[a+1][1],x=Math.sqrt((m-r)*(m-r)+(h-l)*(h-l)),u=(h-l)/x,y=(m-r)/x,p=x/n;if(p>1){for(let S=1;S<=p-1;S++){const M=S*n,X=y*M+r,o=u*M+l;f.push([X,o])}const R=(x+Math.floor(p-1)*n)/2,N=y*R+r,I=u*R+l;f.push([N,I])}f.push([m,h])}}return oe(e)?new k({rings:s,spatialReference:e.spatialReference}):new $({paths:s,spatialReference:e.spatialReference})}function z(e,n,i){if(n){const s=ce(e,1e6);e=Y(s,!0)}return i&&(e=D(e,i)),e}function T(e,n,i){if(Array.isArray(e)){const s=e[0];if(s>n){const t=L(s,n);e[0]=s+t*(-2*n)}else if(s<i){const t=L(s,i);e[0]=s+t*(-2*i)}}else{const s=e.x;if(s>n){const t=L(s,n);e=e.clone().offset(t*(-2*n),0)}else if(s<i){const t=L(s,i);e=e.clone().offset(t*(-2*i),0)}}return e}function fe(e,n){let i=-1;for(let s=0;s<n.cutIndexes.length;s++){const t=n.cutIndexes[s],f=n.geometries[s],a=O(f);for(let r=0;r<a.length;r++){const l=a[r];l.some(m=>{if(m[0]<180)return!0;{let h=0;for(let u=0;u<l.length;u++){const y=l[u][0];h=y>h?y:h}h=Number(h.toFixed(9));const x=-360*L(h,180);for(let u=0;u<l.length;u++){const y=f.getPoint(r,u);f.setPoint(r,u,y.clone().offset(x,0))}return!0}})}if(t===i){if(re(e))for(const r of O(f))e[t]=e[t].addRing(r);else if(ie(e))for(const r of O(f))e[t]=e[t].addPath(r)}else i=t,e[t]=f}return e}async function ae(e,n,i){var X;if(!Array.isArray(e))return ae([e],n);n&&typeof n!="string"&&G.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:(X=n==null?void 0:n.url)!=null?X:H.geometryServiceUrl;let t,f,a,r,l,m,h,x,u=0;const y=[],p=[];for(const o of e)if(K(o))p.push(o);else if(t||(t=o.spatialReference,f=Q(t),a=t.isWebMercator,m=a?102100:4326,r=A[m].maxX,l=A[m].minX,h=A[m].plus180Line,x=A[m].minus180Line),f)if(o.type==="mesh")p.push(o);else if(o.type==="point")p.push(T(o.clone(),r,l));else if(o.type==="multipoint"){const c=o.clone();c.points=c.points.map(g=>T(g,r,l)),p.push(c)}else if(o.type==="extent"){const c=o.clone()._normalize(!1,!1,f);p.push(c.rings?new k(c):c)}else if(o.extent){const c=o.extent,g=L(c.xmin,l)*(2*r);let d=g===0?o.clone():D(o.clone(),g);c.offset(g,0),c.intersects(h)&&c.xmax!==r?(u=c.xmax>u?c.xmax:u,d=z(d,a),y.push(d),p.push("cut")):c.intersects(x)&&c.xmin!==l?(u=c.xmax*(2*r)>u?c.xmax*(2*r):u,d=z(d,a,360),y.push(d),p.push("cut")):p.push(d)}else p.push(o.clone());else p.push(o);let R=L(u,r),N=-90;const I=R,S=new $;for(;R>0;){const o=360*R-180;S.addPath([[o,N],[o,-1*N]]),N*=-1,R--}if(y.length>0&&I>0){const o=fe(y,await ee(s,y,S,i)),c=[],g=[];for(let w=0;w<p.length;w++){const b=p[w];if(b!=="cut")g.push(b);else{const j=o.shift(),J=e[w];V(J)&&J.type==="polygon"&&J.rings&&J.rings.length>1&&j.rings.length>=J.rings.length?(c.push(j),g.push("simplify")):g.push(a?W(j):j)}}if(!c.length)return g;const d=await te(s,c,i),P=[];for(let w=0;w<g.length;w++){const b=g[w];b!=="simplify"?P.push(b):P.push(a?W(d.shift()):d.shift())}return P}const M=[];for(let o=0;o<p.length;o++){const c=p[o];if(c!=="cut")M.push(c);else{const g=y.shift();M.push(a===!0?W(g):g)}}return M}export{ae as L};
